% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }



\title{postqe Documentation}
\date{October 18, 2017}
\release{0.1}
\author{M. Palumbo, D. Brunato, P. D. Delugas}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\setcounter{tocdepth}{2}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Introduction}
\label{introduction:introduction}\label{introduction:id1}\label{introduction:welcome-to-postqe-s-documentation}\label{introduction::doc}
\code{postqe} is a Python package for postprocessing of results obtained with the Quantum Espresso (\emph{QE}) code \footnote[1]{
\href{http://www.quantum-espresso.org/}{http://www.quantum-espresso.org/}
}. The package provides Python API functions for the most common tasks, such as plotting the charge density or fitting the total energy with an equation of state (EOS). It also makes available in Python some QE functionalities using the F2PY code \footnote[2]{
\href{https://docs.scipy.org/doc/numpy-dev/f2py/}{https://docs.scipy.org/doc/numpy-dev/f2py/}
} and wrappers to generate Python modules from QE dynamically linked libraries. Finally, it also includes an interface with the popular Atomic Simulation Environment (\emph{ASE}) \footnote[3]{
\href{https://wiki.fysik.dtu.dk/ase/}{https://wiki.fysik.dtu.dk/ase/}
}, from which in fact leverages for some functionalities.

The package implents some Python classes for handling the most important quantities, such as the charge or a potential. Some classes are derived from \emph{ASE} and adapted to the postprocessing needs of QE.

It is meant to be imported into your own Python scripts or used from the command line interface (see the Tutorial for some examples). It is also meant for people who want to tinker with the code and adapt it to their own needs. The package is based on \emph{numpy}, \emph{scipy}, \emph{matplotlib} and \emph{ASE} libraries.

Finally it is a software framework where Quantum Espresso developers or advanced users may implement new functionalities which are needed by the community. In this respect, it offers the possibility to develop code in different languages (Python, C/C++, Fortran) and then use Python to ``glue'' everything together.

Current features of the package include:
\begin{itemize}
\item {} 
Fit the total energy \(E_{tot}(V)\) with an equation of state (Murnaghan, Vinet, Birch, etc.)

\item {} 
Calculate and plot the electronic band structure

\item {} 
Calculate and plot the electronic density of states (DOS)

\item {} 
Plot 1D, 2D or 3D sections of the charge density

\item {} 
Plot 1D, 2D or 3D sections of different potentials (Hartree, exchange-correlation, etc.)

\end{itemize}


\section{Installation}
\label{introduction:installation}
You can download all package files from GitHub  and then install it with the command:

\begin{Verbatim}[commandchars=\\\{\}]
sudo python setup.py install
\end{Verbatim}

The most useful functions for the user are directly accessible. You can import all of them as:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{postqe} \PYG{k+kn}{import} \PYG{o}{*}
\end{Verbatim}

or you can import only the ones you need. The above command also makes available a number of useful constants that you can use for unit conversions.

More functions are available as submodules. See the related documentation for more details. Note, however, that most of these functions are less well documented and are meant for advanced users or if you want to tinker with the code.


\section{General notes}
\label{introduction:general-notes}

\subsection{Version}
\label{introduction:version}
The package is still under development. Hence, it may contain bugs and some features may not be fully implemented. Use at your own risk.


\subsection{Plotting}
\label{introduction:plotting}
\code{postqe} uses the \emph{matplotlib} library for Plotting. Some functions in the package are simply useful wrappers for \emph{matplotlib} functionalities of common uses. They return a \emph{matplotlib} object which can be further adapted to specific needs and personal taste. Alternatively, you can of course manipulate and plot the post-procecessed data with any other Python tool of your choice.

It is also possible to export the charge (and various potentials) into text files according to different available formats (XSF XCrySDen format, cube Gaussian format, Gnuplot formats, contour.x and plotrho.x formats).


\chapter{Tutorial}
\label{tutorial:id1}\label{tutorial:tutorial}\label{tutorial::doc}
This is a simple tutorial demonstrating the main functionalities of \code{postqe}. The examples below show how to use the package to perform the most common tasks. The code examples can be found in the directory \emph{examples} of the package and can be run either as interactive sessions in your Python interpreter or as scripts. It is also possible to obtain the same results using the command line and the available commands and options of \code{postqe}, as detailed in the following.
You should run the example scripts or command-line commands from the corresponding example directory, which contains the proper input files.

The tutorial is based on the following examples:

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Example n.
} & \textsf{\relax 
Description
}\\
\hline
1
 & 
Fitting \(E_{tot}(V)\) for a cubic (isotropic) system using Murnaghan EOS
\\
\hline
2
 & 
Calculate and plot the band structure of silicon
\\
\hline
3
 & 
Calculate and plot the density of states (DOS) of silicon
\\
\hline
4
 & 
Plotting a 1D section of the charge density
\\
\hline
5
 & 
Plotting a 2D section of the charge density
\\
\hline
6
 & 
Plotting 1D sections of different potentials
\\
\hline\end{tabulary}


Several simplified plotting functions are available in \code{postqe} and are used in the following tutorial to show what you can plot.
Note however that all plotting functions need the matplotlib library, which must be available on your system and can be used to further tailor your plot.


\section{Fitting the total energy using Murnaghan EOS (examples 1)}
\label{tutorial:fitting-the-total-energy-using-murnaghan-eos-examples-1}
The simplest task you can do with \code{postqe} is to fit the total energy as a function of volume \(E_{tot}(V)\). You can use
an equation of state (EOS) such as Murnaghan's or similar.  Currently you can use Murnaghan, Vinet, Birch, Birch-Murnaghan, Pourier-Tarantola and Anton-schmidt EOS and 3rd order (direct and inverse) polynomials in \code{postqe}. See the documentation of \code{get\_eos()} for details.

Let's see how to fit \(E_{tot}(V)\). This is the case of isotropic cubic systems (simple cubic, body centered cubic, face centered cubic) or systems which can be approximated as isotropic (for example an hexagonal system with nearly constant \(c/a\) ratio).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{postqe} \PYG{k+kn}{import} \PYG{n}{units}\PYG{p}{,} \PYG{n}{get\PYGZus{}eos}

\PYG{n}{eos} \PYG{o}{=} \PYG{n}{get\PYGZus{}eos}\PYG{p}{(}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Nienergies.dat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{eos\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{murnaghan}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{v0}\PYG{p}{,} \PYG{n}{e0}\PYG{p}{,} \PYG{n}{B} \PYG{o}{=} \PYG{n}{eos}\PYG{o}{.}\PYG{n}{fit}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Print some data and plot}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Equilibrium volume = }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{v0}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ Ang\PYGZca{}3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Equilibrium energy = }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{e0}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ eV}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Equilibrium Bulk modulus = }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{B} \PYG{o}{/} \PYG{n}{units}\PYG{o}{.}\PYG{n}{kJ} \PYG{o}{*} \PYG{l+m+mf}{1.0e24}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ GPa}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{eos}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig} \PYG{o}{=} \PYG{n}{eos}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ni\PYGZhy{}eos.png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{show}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Save the plot in a different format (pdf) with Matplotlib if you like}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{figure}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{figure.pdf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{format}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pdf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

The \code{get\_eos()} needs in input a file with two columns: the first with the volumes (in \(a.u.^3\)), the second with energies (in \(Ryd/cell\)). You also define here what EOS to use, in this case Murnaghan's. This function returns an \emph{eos} object. The method \code{fit()} performs the fitting and returns the equilibrium volume \emph{v0}, energy \emph{e0} and bulk modulus \emph{B}. The fitting results can then be printed or further processed.

Optionally, you can plot the results with the \code{plot\_EV()}. The original data are represented as points.

\includegraphics{{Ni-eos}.png}

It is possible to obtain the same results using the command line and the available commands and options of \code{postqe}. For this example, you must type:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} postqe eos \PYGZhy{}prefix Nienergies.dat \PYGZhy{}eos\PYGZus{}type murnaghan \PYGZhy{}fileout eos \PYGZhy{}fileplot Ni\PYGZhy{}eos.png
\end{Verbatim}

Note that you can get help from the command line with the -h or --help options. Try for example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} postqe \PYGZhy{}h
\PYGZdl{} postqe eos \PYGZhy{}h
\end{Verbatim}


\section{Calculate and plot the band structure of silicon (examples 2)}
\label{tutorial:calculate-and-plot-the-band-structure-of-silicon-examples-2}
This example shows how to calculate the electronic band structure of silicon with \code{postqe}. All necessary information is extracted from the standard xml output file of Quantum Espresso, produced by a proper calculation along the desired path in the Brillouin zone.

\begin{Verbatim}[commandchars=\\\{\}]

\PYG{n}{bs} \PYG{o}{=} \PYG{n}{get\PYGZus{}band\PYGZus{}structure}\PYG{p}{(}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Si}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{schema}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../../schemas/qes.xsd}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{reference\PYGZus{}energy}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{fig} \PYG{o}{=} \PYG{n}{bs}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{emin}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{emax}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{show}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{,} \PYG{n}{filename}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sibands.png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

The \code{get\_band\_structure()} needs a parameter \emph{prefix} which identies the system and the corresponding xml file (prefix.xml). As customary in Quantum Espresso, you can optionally provide an \emph{outdir} contain the full path to the file (and other output files). If not provided, \code{postqe} tries to get the ESPRESSO\_TMPDIR environment variable. If this fails too, it assumes the output file are in the current working directory.
The \emph{schema} (optional) parameter allows the code to properly parse and validate the xml file. The necessary xml schema is fetched from the source specified in the xml files itself, but the user can override this default schema by setting the \emph{schema} parameter.
The parameter \emph{reference\_energy} (usually the Fermi level) allows you to shift the plot accordingly. \code{get\_band\_structure()} returns a band structure object which can be further processed.
For example, the method \code{plot()} creates a figure and save it in a png file.

\includegraphics{{bandsplot}.png}

The above results can be obtained from the command line typing:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} postqe bands \PYGZhy{}prefix Si \PYGZhy{}schema ../../schemas/qes.xsd
\end{Verbatim}


\section{Calculate and plot the density of states (DOS) of silicon (examples 3)}
\label{tutorial:calculate-and-plot-the-density-of-states-dos-of-silicon-examples-3}
This example shows how to calculate the electronic density of states (DOS) with \code{postqe}. All necessary information is extracted from the standard xml output file. The following code shows how to do it for silicon (xml output file: Si.xml)

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{postqe} \PYG{k+kn}{import} \PYG{n}{get\PYGZus{}dos}

\PYG{c+c1}{\PYGZsh{} get a DOS object}
\PYG{n}{dos} \PYG{o}{=} \PYG{n}{get\PYGZus{}dos}\PYG{p}{(}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Si}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{schema}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../../schemas/qes.xsd}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{width}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{npts}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} get the dos and energies for further processing}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{dos}\PYG{o}{.}\PYG{n}{get\PYGZus{}dos}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{e} \PYG{o}{=} \PYG{n}{dos}\PYG{o}{.}\PYG{n}{get\PYGZus{}energies}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the DOS with Matplotlib...}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib.pyplot} \PYG{k+kn}{as} \PYG{n+nn}{plt}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{e}\PYG{p}{,} \PYG{n}{d}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{energy [eV]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DOS}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{figure.png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} save DOS in a file}
\PYG{n}{dos}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DOS.out}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

The \code{get\_dos()} needs in input the xml file produced by pw.x, after a proper DOS calculation. This is identified using \emph{label} which may contain the full path to the file (.xml is automatically added). The \emph{schema} (optional) parameter allows the code to properly parse and validate the xml file.  You must also specify the number of energy steps in the DOS (\emph{npts}), plus the Gaussian broadening (\emph{width}). \code{get\_dos()} then returns a DOS object.

The DOS values and the corresponding energies can be obtained from the DOS object using the methods \code{get\_dos()} and \code{get\_energies()}. If you want you can further manipulate these values. For example you can make a plot with the Python library \emph{Matplotlib}. The output plot looks like the following:

\includegraphics{{figure}.png}

You can of course continue to calculate other quantities in your script.

The above results can be obtained from the command line typing:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} postqe dos \PYGZhy{}prefix Si \PYGZhy{}schema ../../schemas/qes.xsd \PYGZhy{}npts \PYG{l+m}{200} \PYGZhy{}width 0.5 \PYGZhy{}fileplot figure.png
\end{Verbatim}


\section{Plotting a 1D section of the charge density  (examples 4)}
\label{tutorial:plotting-a-1d-section-of-the-charge-density-examples-4}
A common task you can perform with \code{postqe} is to plot the electronic charge density along one direction. The charge is read from the HDF5
output file create by the Quantum Espresso calculation in \emph{outdir}. Additional information are extracted from the standard xml output file, identified by the \emph{prefix} parameter in the \code{get\_charge()} function. The \emph{schema} (optional) parameter allows the code to properly parse and validate the xml file. The full code to do this is shown below:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{postqe} \PYG{k+kn}{import} \PYG{n}{get\PYGZus{}charge}

\PYG{n}{charge} \PYG{o}{=} \PYG{n}{get\PYGZus{}charge}\PYG{p}{(}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ni}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{schema}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../../schemas/qes.xsd}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{charge}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{outputcharge.dat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{figure} \PYG{o}{=} \PYG{n}{charge}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x0}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{e1}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nx}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}
\PYG{n}{figure}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{figure\PYGZus{}1.png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

The call to \code{get\_charge()} creates a \emph{charge} object. The charge can be written in a text file using the method \code{write()}. The call to the method \code{plot()} returns a \emph{Matplotlib} figure object containing a 1D section plot of the charge from the point \emph{x0} along the direction \emph{e1}.
By default, the charge is plotted from the point (0,0,0) along the direction (1,0,0). The \emph{Matplotlib} figure object can be further modified with the standard methods of this library. For example, the plot can be save in a png file using the method \code{savefig()}. The result is shown below.

\includegraphics{{figure_1}.png}

The above results can be obtained from the command line typing:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} postqe charge \PYGZhy{}prefix Ni \PYGZhy{}schema ../../schemas/qes.xsd \PYGZhy{}fileout outputcharge.dat \PYGZhy{}x0 0,0,0 \PYGZhy{}e1 1,0,0 \PYGZhy{}nx 50
\end{Verbatim}


\section{Plotting a 2D section of the charge density  (examples 5)}
\label{tutorial:plotting-a-2d-section-of-the-charge-density-examples-5}
This example is similar to the previous one except for producing a 2D plot of a planar section of the electronic charge density. The plane is defined
by an initial point \emph{x0} and two vectors, \emph{e1} and \emph{e2} which define the plane, which are given as parameters to the method \code{plot()} together with \emph{dim=2} to define a 2D plot.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{postqe} \PYG{k+kn}{import} \PYG{n}{get\PYGZus{}charge}

\PYG{n}{charge} \PYG{o}{=} \PYG{n}{get\PYGZus{}charge}\PYG{p}{(}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ni}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{schema}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../../schemas/qes.xsd}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{figure} \PYG{o}{=} \PYG{n}{charge}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x0}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{e1}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{e2}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nx}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{ny}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{dim}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{figure}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}1.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{figure}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}1.pdf}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{format}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pdf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

The resulting \emph{Matplotlib} plot is

\includegraphics{{figure_11}.png}

The above results can be obtained from the command line typing:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} postqe charge \PYGZhy{}prefix Ni \PYGZhy{}schema ../../schemas/qes.xsd \PYGZhy{}fileout outputcharge.dat \PYGZhy{}dim \PYG{l+m}{2} \PYGZhy{}x0 0,0,0 \PYGZhy{}e1 1,0,0 \PYGZhy{}e2 0,1,0 \PYGZhy{}nx \PYG{l+m}{50} \PYGZhy{}ny\PYG{o}{=}50
\end{Verbatim}


\section{Plotting 1D sections of different potentials  (examples 6)}
\label{tutorial:plotting-1d-sections-of-different-potentials-examples-6}
This example computes all the different potentials available, i.e. the bare potential \(V_{bare}\), the Hartree potential \(V_{H}\), the exchange-correlation potential \(V_{xc}\) and the total potential \(V_{tot}=V_{bare}+V_{H}+V_{xc}\). All necessary information is taken from the xml output file of QE and the HDF5 charge file. The pseudopotential file is also necessary to compute \(V_{bare}\).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{postqe} \PYG{k+kn}{import} \PYG{n}{get\PYGZus{}potential}

\PYG{n}{v\PYGZus{}bare} \PYG{o}{=} \PYG{n}{get\PYGZus{}potential}\PYG{p}{(}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ni}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{schema}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../../schemas/qes.xsd}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pot\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v\PYGZus{}bare}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{v\PYGZus{}bare}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v\PYGZus{}bare.dat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{fig1} \PYG{o}{=} \PYG{n}{v\PYGZus{}bare}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x0}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{e1}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nx}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{)}
\PYG{n}{fig1}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}v\PYGZus{}bare.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{v\PYGZus{}h} \PYG{o}{=} \PYG{n}{get\PYGZus{}potential}\PYG{p}{(}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ni}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{schema}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../../schemas/qes.xsd}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pot\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v\PYGZus{}h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{v\PYGZus{}h}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v\PYGZus{}h.dat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{fig2} \PYG{o}{=} \PYG{n}{v\PYGZus{}h}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x0}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{e1}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nx}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{)}
\PYG{n}{fig2}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}v\PYGZus{}h.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{v\PYGZus{}xc} \PYG{o}{=} \PYG{n}{get\PYGZus{}potential}\PYG{p}{(}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ni}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{schema}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../../schemas/qes.xsd}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pot\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v\PYGZus{}xc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{v\PYGZus{}xc}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v\PYGZus{}xc.dat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{fig3} \PYG{o}{=} \PYG{n}{v\PYGZus{}xc}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x0}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{e1}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nx}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{)}
\PYG{n}{fig3}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}v\PYGZus{}xc.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{v\PYGZus{}tot} \PYG{o}{=} \PYG{n}{get\PYGZus{}potential}\PYG{p}{(}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ni}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{schema}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../../schemas/qes.xsd}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{pot\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v\PYGZus{}tot}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{v\PYGZus{}tot}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{v\PYGZus{}tot.dat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{fig4} \PYG{o}{=} \PYG{n}{v\PYGZus{}tot}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{x0}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{e1}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nx}\PYG{o}{=}\PYG{l+m+mi}{50}\PYG{p}{)}
\PYG{n}{fig4}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{figure\PYGZus{}v\PYGZus{}tot.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

The code essentialy call the function \code{get\_potential()}, which returns a potential object of the type defined in \emph{pot\_typ}. The \code{write()} and \code{plot()} methods are then used to write the output in a text file and produce the plots as in the previous example (in fact they accept the same parameters).

The output figures are as follows:

\includegraphics{{figure_v_bare}.png}

\includegraphics{{figure_v_h}.png}

\includegraphics{{figure_v_xc}.png}

\includegraphics{{figure_v_tot}.png}

The above results can be obtained from the command line typing:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} postqe potential \PYGZhy{}pot\PYGZus{}type v\PYGZus{}bare \PYGZhy{}prefix Ni \PYGZhy{}schema ../../schemas/qes.xsd \PYGZhy{}fileout v\PYGZus{}bare.dat \PYGZhy{}x0 0,0,0 \PYGZhy{}e1 1,0,0 \PYGZhy{}nx 50
\PYGZdl{} postqe potential \PYGZhy{}pot\PYGZus{}type v\PYGZus{}h \PYGZhy{}prefix Ni \PYGZhy{}schema ../../schemas/qes.xsd \PYGZhy{}fileout v\PYGZus{}h.dat \PYGZhy{}x0 0,0,0 \PYGZhy{}e1 1,0,0 \PYGZhy{}nx 50
\PYGZdl{} postqe potential \PYGZhy{}pot\PYGZus{}type v\PYGZus{}xc \PYGZhy{}prefix Ni \PYGZhy{}schema ../../schemas/qes.xsd \PYGZhy{}fileout v\PYGZus{}xc.dat \PYGZhy{}x0 0,0,0 \PYGZhy{}e1 1,0,0 \PYGZhy{}nx 50
\PYGZdl{} postqe potential \PYGZhy{}pot\PYGZus{}type v\PYGZus{}tot \PYGZhy{}prefix Ni \PYGZhy{}schema ../../schemas/qes.xsd \PYGZhy{}fileout v\PYGZus{}tot.dat \PYGZhy{}x0 0,0,0 \PYGZhy{}e1 1,0,0 \PYGZhy{}nx 50
\end{Verbatim}


\section{Export formats  (examples 7)}
\label{tutorial:export-formats-examples-7}
This is a (rather boring) example to illustrate the different formats available to export in a text file the charge extracted with \code{postqe}. The following code computes different 1, 2 and 3D sections of the charge and export the results in some available formats. These exported files can then be viewed using the corresponding package. Note that for 3D sections, no plot is generated by \code{postqe} and you can only export the charge in XSF (XCrySDen) and cube (Gaussian) formats to visualize it with these packages.
Note that the number of points for the grids is small to make the calculations faster. For 2D and especially 3D sections, a significant time may be necessary for the calculations.


\chapter{postqe package}
\label{postqe:postqe-package}\label{postqe::doc}

\section{Submodules}
\label{postqe:submodules}
Additional functions are available as submodules. Please note the documentation of these functions is still ongoing and can be incomplete or wrong.


\section{postqe.api module}
\label{postqe:postqe-api-module}\label{postqe:module-postqe.api}\index{postqe.api (module)}
A collection of functions defining postqe API and exposed to the user.
\index{comput\_dos() (in module postqe.api)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.api.comput_dos}\pysiglinewithargsret{\code{postqe.api.}\bfcode{comput\_dos}}{\emph{prefix}, \emph{outdir=None}, \emph{schema=None}, \emph{width=0.01}, \emph{window=None}, \emph{npts=100}, \emph{fileout='`}, \emph{fileplot='dosplot.png'}, \emph{show=True}}{}
This function returns an DOS object from an output xml Espresso file containing the
results of a DOS calculation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{prefix}} -- prefix of saved output files

\item {} 
\textbf{\texttt{outdir}} -- directory containing the input data. Default to the value of
ESPRESSO\_TMPDIR environment variable if set or current directory (`.') otherwise

\item {} 
\textbf{\texttt{schema}} -- the XML schema to be used to read and validate the XML output file

\item {} 
\textbf{\texttt{width}} -- width of the gaussian to be used for the DOS (in eV)

\item {} 
\textbf{\texttt{= emin, emax}} (\emph{\texttt{window}}) -- defines the minimun and maximun energies for the DOS

\item {} 
\textbf{\texttt{npts}} -- number of points of the DOS

\item {} 
\textbf{\texttt{fileout}} -- output file with DOS results (default='`, not written).

\item {} 
\textbf{\texttt{fileplot}} -- output plot file (default='dosplot') in png format.

\item {} 
\textbf{\texttt{show}} -- True -\textgreater{} plot results with Matplotlib; None or False -\textgreater{} do nothing. Default = True

\end{itemize}

\item[{Returns}] \leavevmode
a DOS object and a Matplotlib figure object

\end{description}\end{quote}

\end{fulllineitems}

\index{compute\_band\_structure() (in module postqe.api)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.api.compute_band_structure}\pysiglinewithargsret{\code{postqe.api.}\bfcode{compute\_band\_structure}}{\emph{prefix}, \emph{outdir=None}, \emph{schema=None}, \emph{reference\_energy=0}, \emph{emin=-50}, \emph{emax=50}, \emph{fileplot='bandsplot.png'}, \emph{show=True}}{}
This function returns a ``band structure'' object from an output xml Espresso file
containing the results of a proper calculation along a path in the Brilluoin zone.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{prefix}} -- prefix of saved output file

\item {} 
\textbf{\texttt{outdir}} -- directory containing the input data. Default to the value of
ESPRESSO\_TMPDIR environment variable if set or current directory (`.') otherwise

\item {} 
\textbf{\texttt{schema}} -- the XML schema to be used to read and validate the XML output file

\item {} 
\textbf{\texttt{reference\_energy}} -- the Fermi level, defines the zero of the plot along y axis

\item {} 
\textbf{\texttt{emin}} -- the minimum energy for the band plot (default=-50)

\item {} 
\textbf{\texttt{emax}} -- the maximum energy for the band plot (default=50)

\item {} 
\textbf{\texttt{fileplot}} -- output plot file (default='bandsplot.png') in png format.

\item {} 
\textbf{\texttt{show}} -- True -\textgreater{} plot results with Matplotlib; None or False -\textgreater{} do nothing. Default = True

\end{itemize}

\item[{Returns}] \leavevmode
an ASE band structure object and a Matplotlib figure object

\end{description}\end{quote}

\end{fulllineitems}

\index{compute\_charge() (in module postqe.api)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.api.compute_charge}\pysiglinewithargsret{\code{postqe.api.}\bfcode{compute\_charge}}{\emph{prefix}, \emph{outdir=None}, \emph{schema=None}, \emph{fileout='`}, \emph{x0=(0.0}, \emph{0.0}, \emph{0.0)}, \emph{e1=(1.0}, \emph{0.0}, \emph{0.0)}, \emph{nx=50}, \emph{e2=(0.0}, \emph{1.0}, \emph{0.0)}, \emph{ny=50}, \emph{e3=(0.0}, \emph{0.0}, \emph{1.0)}, \emph{nz=50}, \emph{radius=1}, \emph{dim=1}, \emph{ifmagn='total'}, \emph{plot\_file='`}, \emph{method='FFT'}, \emph{format='gnuplot'}, \emph{show=True}}{}
Returns an Charge object from an output xml Espresso file and the
corresponding HDF5 charge file containing the results of a calculation.
Returns also a Matplotlib figure object from a 1D or 2D section of the charge.
It also (optionally) exports the charge (1, 2 or 3D section) in a text file according to
different formats (XSF, cube, Gnuplot, etc.).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{prefix}} -- prefix of saved output file

\item {} 
\textbf{\texttt{outdir}} -- directory containing the input data. Default to the value of
ESPRESSO\_TMPDIR environment variable if set or current directory (`.') otherwise

\item {} 
\textbf{\texttt{schema}} -- the XML schema to be used to read and validate the XML output file

\item {} 
\textbf{\texttt{fileout}} -- text file with the full charge data as in the HDF5 file. Default='`, nothing is written.

\item {} 
\textbf{\texttt{x0}} -- 3D vector (a tuple), origin of the line

\item {} 
\textbf{\texttt{e2, e3}} (\emph{\texttt{e1,}}) -- 3D vectors (tuples) which determines the plotting lines

\item {} 
\textbf{\texttt{ny, nz}} (\emph{\texttt{nx,}}) -- number of points along e1, e2, e3

\item {} 
\textbf{\texttt{radius}} -- radious of the sphere in the polar average method

\item {} 
\textbf{\texttt{dim}} -- 1, 2, 3 for a 1D, 2D or 3D section respectively

\item {} 
\textbf{\texttt{ifmagn}} -- for a magnetic calculation, `total' plot the total charge, `up' plot the charge with spin up,
`down' for spin down

\item {} 
\textbf{\texttt{plotfile}} -- file where plot data are exported in the chosen format (Gnuplot, XSF, cube Gaussian, etc.)

\item {} 
\textbf{\texttt{method}} -- 
interpolation method. Available choices are:

`FFT' -\textgreater{} Fourier interpolation (default)

`polar' -\textgreater{} 2D polar plot on a sphere

`spherical' -\textgreater{} 1D plot of the spherical average

`splines' -\textgreater{} not implemented


\item {} 
\textbf{\texttt{format}} -- 
format of the (optional) exported file. Available choices are:

`gnuplot' -\textgreater{} plain text format for Gnuplot (default). Available for 1D and 2D sections.

`xsf' -\textgreater{} XSF format for the XCrySDen program. Available for 2D and 3D sections.

`cube' -\textgreater{} cube Gaussian format. Available for 3D sections.

`contour' -\textgreater{} format for the contour.x code of Quantum Espresso.

`plotrho' -\textgreater{} format for the plotrho.x code of Quantum Espresso.


\item {} 
\textbf{\texttt{show}} -- if True, show the Matplotlib plot (only for 1D and 2D sections)

\end{itemize}

\item[{Returns}] \leavevmode
a Charge object and a Matplotlib figure object for 1D and 2D sections,
a Charge object and None for 3D sections

\end{description}\end{quote}

\end{fulllineitems}

\index{compute\_eos() (in module postqe.api)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.api.compute_eos}\pysiglinewithargsret{\code{postqe.api.}\bfcode{compute\_eos}}{\emph{prefix}, \emph{outdir=None}, \emph{eos\_type='murnaghan'}, \emph{fileout='`}, \emph{fileplot='EOSplot'}, \emph{show=True}, \emph{ax=None}}{}
Fits an Equation of state of type \emph{eos\_type}, writes the results into \emph{fileout} (optionally) and creates a Matplotlib
figure. Different equation of states are available (see below).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{prefix}} -- name of the input file with volumes and energies

\item {} 
\textbf{\texttt{outdir}} -- directory containing the input data. Default to the value of
ESPRESSO\_TMPDIR environment variable if set, or current directory (`.') otherwise

\item {} 
\textbf{\texttt{eos\_type}} -- 
type of equation of state (EOS) for fitting. Available types are:

`murnaghan' (default) -\textgreater{} Murnaghan EOS, PRB 28, 5480 (1983)

`sjeos' -\textgreater{} A third order inverse polynomial fit, PhysRevB.67.026103
\begin{quote}

E(V) = c\_0 + c\_1 t + c\_2 t\textasciicircum{}2  + c\_3 t\textasciicircum{}3 ,  t = V\textasciicircum{}(-1/3)
\end{quote}

`taylor' -\textgreater{} A third order Taylor series expansion around the minimum volume

`vinet' -\textgreater{} Vinet EOS, PRB 70, 224107

`birch' -\textgreater{} Birch EOS, Intermetallic compounds: Principles and Practice, Vol I: Principles, p. 195

`birchmurnaghan' -\textgreater{} Birch-Murnaghan EOS, PRB 70, 224107

`pouriertarantola' -\textgreater{} Pourier-Tarantola EOS, PRB 70, 224107

`antonschmidt' -\textgreater{} Anton-Schmidt EOS, Intermetallics 11, 23 - 32(2003)

`p3' -\textgreater{} A third order inverse polynomial fit


\item {} 
\textbf{\texttt{fileout}} -- output file with fitting data and results (default='`, not written).

\item {} 
\textbf{\texttt{fileplot}} -- output plot file (default='EOSplot') in png format.

\item {} 
\textbf{\texttt{show}} -- True -\textgreater{} plot results with Matplotlib; None or False -\textgreater{} do nothing. Default = True

\item {} 
\textbf{\texttt{ax}} -- a Matplotlib ``Axes'' instance (see Matplotlib documentation for details). If ax=None (default), creates
a new one

\end{itemize}

\item[{Returns}] \leavevmode
an QEEquationOfState object and a Matplotlib figure object

\end{description}\end{quote}

\end{fulllineitems}

\index{compute\_potential() (in module postqe.api)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.api.compute_potential}\pysiglinewithargsret{\code{postqe.api.}\bfcode{compute\_potential}}{\emph{prefix}, \emph{outdir=None}, \emph{schema=None}, \emph{pot\_type='v\_tot'}, \emph{fileout='`}, \emph{x0=(0.0}, \emph{0.0}, \emph{0.0)}, \emph{e1=(1.0}, \emph{0.0}, \emph{0.0)}, \emph{nx=50}, \emph{e2=(0.0}, \emph{1.0}, \emph{0.0)}, \emph{ny=50}, \emph{e3=(0.0}, \emph{0.0}, \emph{1.0)}, \emph{nz=50}, \emph{radius=1}, \emph{dim=1}, \emph{plot\_file='`}, \emph{method='FFT'}, \emph{format='gnuplot'}, \emph{show=True}}{}
Returns an Potential object from an output xml Espresso file and the
corresponding HDF5 charge file containing the results of a calculation.
Returns also a Matplotlib figure object from a 1D or 2D section of the charge.
It also (optionally) exports the charge (1, 2 or 3D section) in a text file according to
different formats (XSF, cube, Gnuplot, etc.).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{prefix}} -- prefix of saved output file

\item {} 
\textbf{\texttt{outdir}} -- directory containing the input data. Default to the value of
ESPRESSO\_TMPDIR environment variable if set or current directory (`.') otherwise

\item {} 
\textbf{\texttt{schema}} -- the XML schema to be used to read and validate the XML output file

\item {} 
\textbf{\texttt{fileout}} -- text file with the calculate potential data. Default='`, nothing is written.

\item {} 
\textbf{\texttt{x0}} -- 3D vector (a tuple), origin of the line

\item {} 
\textbf{\texttt{e2, e3}} (\emph{\texttt{e1,}}) -- 3D vectors (tuples) which determines the plotting lines

\item {} 
\textbf{\texttt{ny, nz}} (\emph{\texttt{nx,}}) -- number of points along e1, e2, e3

\item {} 
\textbf{\texttt{radius}} -- radious of the sphere in the polar average method

\item {} 
\textbf{\texttt{dim}} -- 1, 2, 3 for a 1D, 2D or 3D section respectively

\item {} 
\textbf{\texttt{plotfile}} -- file where plot data are exported in the chosen format (Gnuplot, XSF, cube Gaussian, etc.)

\item {} 
\textbf{\texttt{method}} -- 
interpolation method. Available choices are:

`FFT' -\textgreater{} Fourier interpolation (default)

`polar' -\textgreater{} 2D polar plot on a sphere

`spherical' -\textgreater{} 1D plot of the spherical average

`splines' -\textgreater{} not implemented


\item {} 
\textbf{\texttt{format}} -- 
format of the (optional) exported file. Available choices are:

`gnuplot' -\textgreater{} plain text format for Gnuplot (default). Available for 1D and 2D sections.

`xsf' -\textgreater{} XSF format for the XCrySDen program. Available for 2D and 3D sections.

`cube' -\textgreater{} cube Gaussian format. Available for 3D sections.

`contour' -\textgreater{} format for the contour.x code of Quantum Espresso.

`plotrho' -\textgreater{} format for the plotrho.x code of Quantum Espresso.


\item {} 
\textbf{\texttt{show}} -- if True, show the Matplotlib plot (only for 1D and 2D sections)

\end{itemize}

\item[{Returns}] \leavevmode
a Potential object and a Matplotlib figure object for 1D and 2D sections,
a Potential object and None for 3D sections

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_band\_structure() (in module postqe.api)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.api.get_band_structure}\pysiglinewithargsret{\code{postqe.api.}\bfcode{get\_band\_structure}}{\emph{prefix}, \emph{outdir=None}, \emph{schema=None}, \emph{reference\_energy=0}}{}
This function returns a ``band structure'' object from an output xml Espresso file
containing the results of a proper calculation along a path in the Brilluoin zone.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{prefix}} -- prefix of saved output file

\item {} 
\textbf{\texttt{outdir}} -- directory containing the input data. Default to the value of
ESPRESSO\_TMPDIR environment variable if set or current directory (`.') otherwise

\item {} 
\textbf{\texttt{schema}} -- the XML schema to be used to read and validate the XML output file

\item {} 
\textbf{\texttt{reference\_energy}} -- the Fermi level, defines the zero of the plot along y axis

\end{itemize}

\item[{Returns}] \leavevmode
an ASE band structure object

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_charge() (in module postqe.api)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.api.get_charge}\pysiglinewithargsret{\code{postqe.api.}\bfcode{get\_charge}}{\emph{prefix}, \emph{outdir=None}, \emph{schema=None}}{}
Returns an Charge object from an output xml Espresso file and the
corresponding HDF5 charge file containing the results of a calculation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{prefix}} -- prefix of saved output file

\item {} 
\textbf{\texttt{outdir}} -- directory containing the input data. Default to the value of
ESPRESSO\_TMPDIR environment variable if set or current directory (`.') otherwise

\item {} 
\textbf{\texttt{schema}} -- the XML schema to be used to read and validate the XML output file

\end{itemize}

\item[{Returns}] \leavevmode
a Charge object

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_dos() (in module postqe.api)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.api.get_dos}\pysiglinewithargsret{\code{postqe.api.}\bfcode{get\_dos}}{\emph{prefix}, \emph{outdir=None}, \emph{schema=None}, \emph{width=0.01}, \emph{window=None}, \emph{npts=100}}{}
This function returns an DOS object from an output xml Espresso file containing the
results of a DOS calculation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{prefix}} -- prefix of saved output file

\item {} 
\textbf{\texttt{outdir}} -- directory containing the input data. Default to the value of
ESPRESSO\_TMPDIR environment variable if set or current directory (`.') otherwise

\item {} 
\textbf{\texttt{schema}} -- the XML schema to be used to read and validate the XML output file

\item {} 
\textbf{\texttt{width}} -- width of the gaussian to be used for the DOS (in eV)

\item {} 
\textbf{\texttt{= emin, emax}} (\emph{\texttt{window}}) -- defines the minimun and maximun energies for the DOS

\item {} 
\textbf{\texttt{npts}} -- number of points of the DOS

\end{itemize}

\item[{Returns}] \leavevmode
a DOS object

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_eos() (in module postqe.api)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.api.get_eos}\pysiglinewithargsret{\code{postqe.api.}\bfcode{get\_eos}}{\emph{prefix}, \emph{outdir=None}, \emph{eos\_type='murnaghan'}}{}
Fits an Equation of state of type \emph{eos} and returns an QEEquationOfState object.
Different equation of states are available (see below).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{prefix}} -- name of the input file with volumes and energies

\item {} 
\textbf{\texttt{outdir}} -- directory containing the input data. Default to the value of
ESPRESSO\_TMPDIR environment variable if set, or current directory (`.') otherwise

\item {} 
\textbf{\texttt{eos\_type}} -- 
type of equation of state (EOS) for fitting. Available types are:

`murnaghan' (default) -\textgreater{} Murnaghan EOS, PRB 28, 5480 (1983)

`sjeos' -\textgreater{} A third order inverse polynomial fit, PhysRevB.67.026103
\begin{quote}

E(V) = c\_0 + c\_1 t + c\_2 t\textasciicircum{}2  + c\_3 t\textasciicircum{}3 ,  t = V\textasciicircum{}(-1/3)
\end{quote}

`taylor' -\textgreater{} A third order Taylor series expansion around the minimum volume

`vinet' -\textgreater{} Vinet EOS, PRB 70, 224107

`birch' -\textgreater{} Birch EOS, Intermetallic compounds: Principles and Practice, Vol I: Principles, p. 195

`birchmurnaghan' -\textgreater{} Birch-Murnaghan EOS, PRB 70, 224107

`pouriertarantola' -\textgreater{} Pourier-Tarantola EOS, PRB 70, 224107

`antonschmidt' -\textgreater{} Anton-Schmidt EOS, Intermetallics 11, 23 - 32(2003)

`p3' -\textgreater{} A third order inverse polynomial fit


\end{itemize}

\item[{Returns}] \leavevmode
an QEEquationOfState object

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_label() (in module postqe.api)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.api.get_label}\pysiglinewithargsret{\code{postqe.api.}\bfcode{get\_label}}{\emph{prefix}, \emph{outdir=None}}{}
\end{fulllineitems}

\index{get\_potential() (in module postqe.api)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.api.get_potential}\pysiglinewithargsret{\code{postqe.api.}\bfcode{get\_potential}}{\emph{prefix}, \emph{outdir=None}, \emph{schema=None}, \emph{pot\_type='v\_tot'}}{}
This function returns an Potential object from an output xml Espresso file and
the corresponding HDF5 charge file containing the results of a calculation.
The available potentials are the bare (pot\_type='v\_bare'), Hartree (pot\_type='v\_h'),
exchange-correlation (pot\_type='v\_xc') and total (pot\_type='v\_tot').
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{prefix}} -- prefix of saved output files

\item {} 
\textbf{\texttt{outdir}} -- directory containing the input data. Default to the value of
ESPRESSO\_TMPDIR environment variable if set or current directory (`.') otherwise

\item {} 
\textbf{\texttt{schema}} -- the XML schema to be used to read and validate the XML output file

\item {} 
\textbf{\texttt{pot\_type}} -- type of the Potential (`v\_tot', ....)

\end{itemize}

\item[{Returns}] \leavevmode
a Potential object

\end{description}\end{quote}

\end{fulllineitems}



\section{postqe.eos module}
\label{postqe:module-postqe.eos}\label{postqe:postqe-eos-module}\index{postqe.eos (module)}
A specialization of ASE EquationOfState class with a modified default EOS type and a write method.
\index{QEEquationOfState (class in postqe.eos)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.eos.QEEquationOfState}\pysiglinewithargsret{\strong{class }\code{postqe.eos.}\bfcode{QEEquationOfState}}{\emph{volumes}, \emph{energies}, \emph{eos='murnaghan'}}{}
Bases: \code{ase.eos.EquationOfState}
\index{write() (postqe.eos.QEEquationOfState method)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.eos.QEEquationOfState.write}\pysiglinewithargsret{\bfcode{write}}{\emph{filename='eos.out'}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{create\_header() (in module postqe.eos)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.eos.create_header}\pysiglinewithargsret{\code{postqe.eos.}\bfcode{create\_header}}{\emph{eos}, \emph{v0}, \emph{e0}, \emph{B}}{}
\end{fulllineitems}



\section{postqe.dos module}
\label{postqe:postqe-dos-module}\label{postqe:module-postqe.dos}\index{postqe.dos (module)}
A specialization of ASE DOS class with a new get\_dos\_int method for computing the integral of the DOS
and a modified  write method to write it properly.
\index{QEDOS (class in postqe.dos)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.dos.QEDOS}\pysiglinewithargsret{\strong{class }\code{postqe.dos.}\bfcode{QEDOS}}{\emph{calc}, \emph{width=0.1}, \emph{window=None}, \emph{npts=201}}{}
Bases: \code{ase.dft.dos.DOS}
\index{get\_dos\_int() (postqe.dos.QEDOS method)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.dos.QEDOS.get_dos_int}\pysiglinewithargsret{\bfcode{get\_dos\_int}}{}{}
Get array of integral DOS values (always for the total DOS).

\end{fulllineitems}

\index{write() (postqe.dos.QEDOS method)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.dos.QEDOS.write}\pysiglinewithargsret{\bfcode{write}}{\emph{filename='dos.out'}}{}
\end{fulllineitems}


\end{fulllineitems}



\section{postqe.charge module}
\label{postqe:postqe-charge-module}\label{postqe:module-postqe.charge}\index{postqe.charge (module)}\index{Charge (class in postqe.charge)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.charge.Charge}\pysiglinewithargsret{\strong{class }\code{postqe.charge.}\bfcode{Charge}}{\emph{*args}, \emph{**kwargs}}{}
Bases: \code{object}

A class for charge density.
\index{plot() (postqe.charge.Charge method)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.charge.Charge.plot}\pysiglinewithargsret{\bfcode{plot}}{\emph{x0=(0.0}, \emph{0.0}, \emph{0.0)}, \emph{e1=(1.0}, \emph{0.0}, \emph{0.0)}, \emph{nx=50}, \emph{e2=(0.0}, \emph{1.0}, \emph{0.0)}, \emph{ny=50}, \emph{e3=(0.0}, \emph{0.0}, \emph{1.0)}, \emph{nz=50}, \emph{radius=1}, \emph{dim=1}, \emph{ifmagn='total'}, \emph{plot\_file='`}, \emph{method='FFT'}, \emph{format='gnuplot'}, \emph{show=True}}{}
Plot a 1D, 2D or 3D section of the charge from x0 along e1 (e2, e3) direction(s) using Fourier interpolation
or another method (see below). For 1D or 2D sections, the code produce a Matplotlib plot. For a 3D plot, the
charge must be exported in `plotfile' with a suitable format (`xsf' or `cube') and can be visualized with
the corresponding external codes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{x0}} -- 3D vector (a tuple), origin of the line

\item {} 
\textbf{\texttt{e2, e3}} (\emph{\texttt{e1,}}) -- 3D vectors (tuples) which determines the plotting lines

\item {} 
\textbf{\texttt{ny, nz}} (\emph{\texttt{nx,}}) -- number of points along e1, e2, e3

\item {} 
\textbf{\texttt{radius}} -- radius of the sphere in the polar average method

\item {} 
\textbf{\texttt{dim}} -- 1, 2, 3 for a 1D, 2D or 3D section respectively

\item {} 
\textbf{\texttt{ifmagn}} -- for a magnetic calculation, `total' plot the total charge, `up' plot the charge with spin up,
`down' for spin down

\item {} 
\textbf{\texttt{plotfile}} -- file where plot data are exported in the chosen format (Gnuplot, XSF, cube Gaussian, etc.)

\item {} 
\textbf{\texttt{method}} -- 
interpolation method. Available choices are:

`FFT' -\textgreater{} Fourier interpolation (default)
`polar' -\textgreater{} 2D polar plot on a sphere
`spherical' -\textgreater{} 1D plot of the spherical average
`splines' -\textgreater{} not implemented


\item {} 
\textbf{\texttt{format}} -- 
format of the (optional) exported file. Available choices are:

`gnuplot' -\textgreater{} plain text format for Gnuplot (default). Available for 1D and 2D sections.
`xsf' -\textgreater{} XSF format for the XCrySDen program. Available for 2D and 3D sections.
`cube' -\textgreater{} cube Gaussian format. Available for 3D sections.
`contour' -\textgreater{} format for the contour.x code of Quantum Espresso
`plotrho' -\textgreater{} format for the plotrho.x code of Quantum Espresso


\item {} 
\textbf{\texttt{show}} -- if True, show the Matplotlib plot (only for 1D and 2D sections)

\end{itemize}

\item[{Returns}] \leavevmode
a Matplotlib figure object for 1D and 2D sections, None for 3D sections

\end{description}\end{quote}

\end{fulllineitems}

\index{read() (postqe.charge.Charge method)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.charge.Charge.read}\pysiglinewithargsret{\bfcode{read}}{\emph{filename}, \emph{nr=None}}{}
Read the charge from a HDF5 file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{filename}} -- HDF5 file with charge data

\item {} 
\textbf{\texttt{nr}} -- a numpy array or list of length 3 containing the grid dimensions

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_calculator() (postqe.charge.Charge method)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.charge.Charge.set_calculator}\pysiglinewithargsret{\bfcode{set\_calculator}}{\emph{calculator}}{}
\end{fulllineitems}

\index{setvars() (postqe.charge.Charge method)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.charge.Charge.setvars}\pysiglinewithargsret{\bfcode{setvars}}{\emph{nr\_temp}, \emph{charge=None}, \emph{charge\_diff=None}}{}
\end{fulllineitems}

\index{write() (postqe.charge.Charge method)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.charge.Charge.write}\pysiglinewithargsret{\bfcode{write}}{\emph{filename}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{Potential (class in postqe.charge)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.charge.Potential}\pysiglinewithargsret{\strong{class }\code{postqe.charge.}\bfcode{Potential}}{\emph{*args}, \emph{pot\_type='v\_tot'}, \emph{**kwargs}}{}
Bases: {\hyperref[postqe:postqe.charge.Charge]{\emph{\code{postqe.charge.Charge}}}}

A class for a potential. This is derived from a Charge class and additionally contains the potential.
\index{compute\_potential() (postqe.charge.Potential method)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.charge.Potential.compute_potential}\pysiglinewithargsret{\bfcode{compute\_potential}}{}{}
Compute the potential from the electronic charge. The type of potential is defined in self.pot\_type when
an instance of the class Potential is create (default `v\_tot').

\end{fulllineitems}

\index{plot() (postqe.charge.Potential method)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.charge.Potential.plot}\pysiglinewithargsret{\bfcode{plot}}{\emph{x0=(0.0}, \emph{0.0}, \emph{0.0)}, \emph{e1=(1.0}, \emph{0.0}, \emph{0.0)}, \emph{nx=50}, \emph{e2=(0.0}, \emph{1.0}, \emph{0.0)}, \emph{ny=50}, \emph{e3=(0.0}, \emph{0.0}, \emph{1.0)}, \emph{nz=50}, \emph{radius=1}, \emph{dim=1}, \emph{plot\_file='`}, \emph{method='FFT'}, \emph{format='gnuplot'}, \emph{show=True}}{}
Plot a 1D, 2D or 3D section of the potential from x0 along e1 (e2, e3) direction(s) using Fourier interpolation
or another method (see below). For 1D or 2D sections, the code produce a Matplotlib plot. For a 3D plot, the
charge must be exported in `plotfile' with a suitable format (`xsf' or `cube') and can be visualized with
the corresponding external codes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{x0}} -- 3D vector (a tuple), origin of the line

\item {} 
\textbf{\texttt{e2, e3}} (\emph{\texttt{e1,}}) -- 3D vectors (tuples) which determines the plotting lines

\item {} 
\textbf{\texttt{ny, nz}} (\emph{\texttt{nx,}}) -- number of points along e1, e2, e3

\item {} 
\textbf{\texttt{radius}} -- radius of the sphere in the polar average method

\item {} 
\textbf{\texttt{dim}} -- 1, 2, 3 for a 1D, 2D or 3D section respectively

\item {} 
\textbf{\texttt{plotfile}} -- file where plot data are exported in the chosen format (Gnuplot, XSF, cube Gaussian, etc.)

\item {} 
\textbf{\texttt{method}} -- 
interpolation method. Available choices are:

`FFT' -\textgreater{} Fourier interpolation (default)
`polar' -\textgreater{} 2D polar plot on a sphere
`spherical' -\textgreater{} 1D plot of the spherical average
`splines' -\textgreater{} not implemented


\item {} 
\textbf{\texttt{format}} -- 
format of the (optional) exported file. Available choices are:

`gnuplot' -\textgreater{} plain text format for Gnuplot (default). Available for 1D and 2D sections.
`xsf' -\textgreater{} XSF format for the XCrySDen program. Available for 2D and 3D sections.
`cube' -\textgreater{} cube Gaussian format. Available for 3D sections.
`contour' -\textgreater{} format for the contour.x code of Quantum Espresso
`plotrho' -\textgreater{} format for the plotrho.x code of Quantum Espresso


\item {} 
\textbf{\texttt{show}} -- if True, show the Matplotlib plot (only for 1D and 2D sections)

\end{itemize}

\item[{Returns}] \leavevmode
a Matplotlib figure object for 1D and 2D sections, None for 3D sections

\end{description}\end{quote}

\end{fulllineitems}

\index{write() (postqe.charge.Potential method)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.charge.Potential.write}\pysiglinewithargsret{\bfcode{write}}{\emph{filename}}{}
Write the potential in a text file. The potential must have been calculated before.
:param filename: name of the output file

\end{fulllineitems}


\end{fulllineitems}

\index{read\_charge\_file\_hdf5() (in module postqe.charge)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.charge.read_charge_file_hdf5}\pysiglinewithargsret{\code{postqe.charge.}\bfcode{read\_charge\_file\_hdf5}}{\emph{filename}, \emph{nr=None}}{}
Reads a charge file written with QE in HDF5 format. \emph{nr = {[}nr1,nr2,nr3{]}} (the dimensions of
the charge k-points grid) are given as parameter (taken for the xml output file by the caller).

Notes: In the new format, the values of the charge in the reciprocal space are stored.
Besides, only the values of the charge \textgreater{} cutoff are stored, together with the Miller indexes.
Hence

\end{fulllineitems}

\index{write\_charge() (in module postqe.charge)}

\begin{fulllineitems}
\phantomsection\label{postqe:postqe.charge.write_charge}\pysiglinewithargsret{\code{postqe.charge.}\bfcode{write\_charge}}{\emph{filename}, \emph{charge}, \emph{header}}{}
Write the charge or another quantity calculated by postqe into a text file \emph{filename}.

\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUspan{xref,std,std-ref}{genindex}

\item {} 
\DUspan{xref,std,std-ref}{modindex}

\item {} 
\DUspan{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{p}
\item {\texttt{postqe.api}}, \pageref{postqe:module-postqe.api}
\item {\texttt{postqe.charge}}, \pageref{postqe:module-postqe.charge}
\item {\texttt{postqe.dos}}, \pageref{postqe:module-postqe.dos}
\item {\texttt{postqe.eos}}, \pageref{postqe:module-postqe.eos}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
